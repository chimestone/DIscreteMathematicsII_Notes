# 第1章 数论和密码学
## 整除性质
命题：如果 a | b 并且 a | c, 那么 a | (b + c)
证明：假设 a | b 且 a | c ，则存在整数 s 和 t ，使得 b = as 和 c =
at 。所以有 b + c = as + at = a(s + t) 。因此， a | (b + c) 。
## 除法算法
命题：若𝑎是整数，𝑏 是正整数，则存在唯一的整数 𝑞 和 𝑟，使得 0≤𝑟<𝑏，
并且 𝑎=𝑏𝑞+r
#### 存在性证明
若 𝑎是整数，𝑏 是正整数，则存在整数 𝑞 和 𝑟，使得 0≤𝑟<𝑏且 𝑎=𝑏𝑞+r
证明：考虑集合 𝑆 = {𝑎 − 𝑏𝑘 | 𝑘𝜖 ℤ 且𝑎 − 𝑏𝑘 ≥ 0} ，以下分情况讨论：
1. 若0 ∈ 𝑆，则 𝑏 | 𝑎，从而可以令𝑞 = 𝑎/𝑏且𝑟 = 0
2. 若0 ∉ 𝑆，我们首先证明𝑆 ≠ ∅，再分情况讨论
	1. 若𝑎 ≥ 0，则𝑎 − 𝑏 \* 0 ∈ 𝑆，也即𝑆 ≠ ∅
	2. 若𝑎 < 0，则𝑎 − 𝑏 \* 𝑎 = 𝑎(1 − 𝑏) ∈ 𝑆
	因此，当0 ∉ 𝑆时， 𝑆 ≠ ∅。以下使用良序原理
	根据良序原理，𝑆 必然有一个最小元素，记为 𝑟 = 𝑎 − 𝑏𝑞
	也即𝑎 = 𝑏𝑞 + 𝑟, 𝑟 ≥ 0，接下来我们只需证明𝑟 < 𝑏
	假设𝑟 ≥ 𝑏，则𝑎 − 𝑏 𝑞 + 1 = 𝑎 − 𝑏𝑞 − 𝑏 = 𝑟 − 𝑏 ≥ 0，且
	𝑎 − 𝑏 𝑞 + 1 ∈ S，也即𝑎 − 𝑏 𝑞 + 1 是比𝑟更小的元素，与假设矛盾
因此， 𝑟 < b
#### 唯一性证明
若 𝑎是整数，𝑏 是正整数，则存在唯一的整数 𝑞 和 𝑟，使 0≤𝑟<𝑏且 𝑎=𝑏𝑞+r
证明：假设存在两组，𝑞 和 𝑟，以及𝑞‘ 和 𝑟’ ，满足
𝑎 = 𝑏𝑞 + 𝑟
𝑎 = 𝑏𝑞’ + 𝑟‘
则， 𝑏𝑞 + 𝑟 = 𝑏𝑞‘ + 𝑟’ 。不失一般性，假设𝑟‘ ≥ 𝑟，则
𝑏 𝑞 − 𝑞’ = 𝑟‘ − 𝑟
因此，𝑏|(𝑟’ − 𝑟 )。
又因为 0 ≤ 𝑟‘ − 𝑟 ≤ 𝑟’ < 𝑏，必然有𝑟‘ − 𝑟 = 0
也即𝑟‘ = 𝑟， 𝑞’ = 𝑞
证明完毕！
## 除数的唯一性
命题: 设 𝑚 为正整数。当且仅当存在一个整数 𝑘 使得𝑎=𝑏+𝑘𝑚，整数 𝑎 和 𝑏 在模 𝑚 意义下同余。
证明：
（仅当）如果 𝑎≡𝑏 (mod 𝑚)，则根据同余的定义，𝑚 整
除 𝑎−𝑏。因此，存在一个整数 𝑘，使得 𝑎−𝑏=𝑘𝑚，即等
价于 𝑎=𝑏+𝑘𝑚.
（当）反过来，如果存在一个整数 𝑘，使得 𝑎=𝑏+𝑘𝑚，
那么 𝑘𝑚=𝑎−𝑏。因此，𝑚 整除 𝑎−𝑏，并且 𝑎≡𝑏 (mod 𝑚).
## 同余式的加法和乘法运算
命题：:设 𝑚 为正整数。如果 𝑎≡𝑏 (mod 𝑚) 且 𝑐≡𝑑 (mod 𝑚)，则𝑎+𝑐≡𝑏+𝑑 (mod 𝑚) 且 𝑎𝑐≡𝑏𝑑 (mod 𝑚)
证明：因为 𝑎≡𝑏 (mod 𝑚) 且 𝑐≡𝑑 (mod 𝑚)，则存在整数 𝑠 和 𝑡，分别使得
𝑏=𝑎+𝑠𝑚和 𝑑=𝑐+𝑡𝑚。
因此,
b + d = (a + sm) + (c + tm) = (a + c) + m(s + t)
b d = (a + sm) (c + tm) = ac + m(at + cs + stm).
因此, a + c ≡ b + d (mod m) and ac ≡ bd (mod m)
## 算数基本定理
### 算数基本定理的存在性证明
命题：每一个大于 1 的正整数都可以表示为一个素数，或者表示为两个或更多素数的乘积，其中素因数按照大小不减的顺序排列
涉及内容：[[第1章 数论和密码学#^9f634d|良序原理]]
证明：假设存在某些整数无法被写成素数相乘的形式，这些整数构成集合𝑆
根据良序原理， 𝑆中必然存在最小元素，记为 𝑎。以下分情况讨论：
- 若𝑎为素数，则𝑎本身就可以写成素数相乘的形式，与假设矛盾。
- 若𝑎为合数，则其必然可以写成两个整数相乘的形式，记为$𝑎 = 𝑎_1 \cdot a_2$。由于$𝑎_1< 𝑎$ ，且𝑎为𝑆中的最小元素，则$𝑎_1∉ S$；同理， $𝑎_2∉ S$。也即，$a_1$和$a_2$都可以表示为素数相乘的形式，分别表示为：
$a_1 = p_1p_2...p_r$
$a_2 = q_1q_2...q_s$
因此，$a = p_1p_2...p_rq_1q_2...q_s$，
也即𝑎也可以写成素数相乘的形式，
𝑎 ∉ S。这与假设矛盾。
综上，𝑆 = ∅，也即所有大于1的正整数都可以表示为素数的乘积
### 算术基本定理的唯一性证明
命题：每一个大于 1 的正整数都唯一表示为一个素数，或者表示为两个或更多素数的乘积，其中素因数按照大小不减的顺序排列
引理1:若 𝑎, 𝑏, 𝑐为正整数，gcd(𝑎, 𝑏) = 1且 𝑎|𝑏𝑐，则𝑎|𝑐.
证明1：根据贝祖定理，存在𝑥和𝑦使得𝑎𝑥 + 𝑏𝑦 = gcd(𝑎, 𝑏) = 1。
两边同时乘上c，则𝑎𝑐𝑥 + 𝑏𝑐𝑦 = 𝑐。又因为𝑎|𝑏𝑐，所以𝑎|𝑐。
引理2：若素数$𝑝|𝑎_1a_2...a_n$，其中$a_1,a_2,...a_n$都为正整数，则$p|a_i$
证明2：显然，当𝑛 = 1引理成立。设引理对𝑛 = 𝑘成立，
以下分两种情况讨论𝑛 = 𝑘 + 1下的情况。
（1）若$gcd(𝑝, 𝑎_1a_2...a_n) = 1$，则根据引理1得 $𝑝|𝑎_{k+1}$
（2）若$gcd(𝑝, 𝑎_1a_2...a_n) = 𝑝$，则根据假设 $𝑝|𝑎_i$(1 ≤ 𝑖 ≤ 𝑘).
综上，引理在𝑛 = 𝑘 + 1也成立。
证明：假设n可以表示为两种素数的乘积$n = p_1p_2...p_s = q_1q_2...q_t$，其中$p_i$和$q_j$均为素数且各自按照非降序排列。去除掉相应的公因子，可得$p_{i1}p_{i2}...p_{iu} = q_{j1}q_{j2}...q_{jv}$，其中$p_{i1}$和$q_{jk}$各不相等。根据引理2，可得$p_{i1} | q_{jk}$，又因为$q_{jk}$为素数，导致矛盾。
## 最大公约数表示成一个线性组合
命题：若 𝑎 和 𝑏 是任意整数且不全为零，则 gcd(𝑎, 𝑏)是集合{𝑎𝑥 + 𝑏𝑦 | 𝑥, 𝑦 ∈ ℤ} 中的最小正整数元素.
证明：设 𝑠是集合{𝑎𝑥+𝑏𝑦 :𝑥, 𝑦∈ ℤ} 中的最小正整数元素。
设 q = a div s，r = a mod s；则 r = a - qs = a - q(ax+by) = a(1-qx) + b(-qy).因此 𝑟 也是 a和b的线性组合。
由于0 ≤ 𝑟 < 𝑠且𝑠是集合{𝑎𝑥+𝑏𝑦 :𝑥, 𝑦∈ ℤ} 中的最小正整数元素，因此𝑟必然为0. 也即𝑠|𝑎。
同理，𝑠|𝑏。因此𝑠是𝑎和𝑏的公约数，且gcd(𝑎, 𝑏) ≥ 𝑠.
另一方面，由于𝑠是a和b的线性组合， gcd (𝑎, 𝑏) | 𝑠。因此gcd(𝑎, 𝑏) ≤ 𝑠。
综上， gcd 𝑎, 𝑏 = 𝑠，也即gcd 𝑎, 𝑏 是集合{𝑎𝑥+𝑏𝑦 |𝑥, 𝑦∈ ℤ} 中的最小正整数元素
## 试除法
命题1：若𝑎是合数, 则𝑎必有小于或等于 𝑎的因子
证明1：设𝑎 = 𝑏𝑐, 其中1 < 𝑏 < 𝑎, 1 < 𝑐 < 𝑎. 显然, b和c
中必有一个小于等于 $\sqrt{𝑎}$. 否则, $𝑏𝑐 \geq 𝑎$, 矛盾.
命题2：若a是合数, 则a必有小于等于 𝑎的素因子
证明2：由以上定理, 𝑎有小于等于 𝑎的因子𝑏.
• 若𝑏是素数, 则结论成立.
• 若𝑏是合数。设𝑏有素因子𝑝，则𝑝 < 𝑏 ≤ $\sqrt{𝑎}$. 且𝑝也是𝑎的因子, 结论也成立.
## 无穷素数
命题：素数的个数是无限的
证明：假设素数的数量是有限的，设所有素数的集合为${p_1,p_2,...p_n}$，令$q = p_1p_2...p_n + 1$，则q必为合数。
根据算数基本定理，q可以写成若干素数的乘积，设其中一个素数是t。
若$t | p_1p_2...p_n$，则$t | (q - p_1p_2...p_n)$也即 t | 1，矛盾。
若$t∤p_1p_2...p_n$，则说明t是$p_1,p_2...p_n$之外的另一个素数，与$\{p_1,p_2,...,p_n\}$是全部素数的假设矛盾。
综上所述，素数的个数是无限的。
**值得一提的是**，这个证明由欧几里得在《几何原本》/"The Elements"中给出，被认为是所有数学证明中最美丽的之一。
## 欧几里得算法
### 引理
命题：令 𝑎 = 𝑏𝑞 + 𝑟, 其中 𝑎, 𝑏, 𝑞和𝑟都是整数. 那么gcd(𝑎, 𝑏) = gcd(𝑏, 𝑟)
证明：• 假设 𝑑 同时整除 𝑎 和 𝑏。那么 𝑑 也整除 𝑎 − 𝑏𝑞 =𝑟。
因此，𝑎 和 𝑏 的任何公约数也必须是 𝑏 和 𝑟 的公约数.
• 假设 𝑑 同时整除 𝑏 和 𝑟。那么 𝑑 也整除 𝑏𝑞 + 𝑟 =𝑎。因此，𝑏 和 𝑟 的任何公约数也必须是 𝑎 和 𝑏 的公约数.
• 因此, gcd(𝑎, 𝑏) = gcd(𝑏, 𝑟)
### 欧几里得算法
证明：假设 𝑎 和 𝑏 是正整数且 𝑎 ≥ 𝑏。设 $𝑟_0 = 𝑎和 𝑟_1 = 𝑏$。
通过连续应用除法算法，我们得到如下结果:
$r_2 = r_0 \mod r_1$，$0 \leq r_2 <r_1$
$r_3 = r_1 \mod r_2$，$0 \leq r_3 < r_2$
...
$r_n = r_{n-2} \mod r_{n-1}$，$0 \leq r_n < r_{n-1}$
得到严格递减的整数序列：$a = r_0 \geq r_1 > r_2 > ... >r_n \geq 0$,该序列中除$r_0$以外最多包含a项，一定会到0.
根据引理：$\gcd(a,b) = \gcd(r_0,r_1) =...= \gcd(r_{n-1},r_{n}) = \gcd(r_n,0) = r_n$
因此，最大公约数就是这个除法序列的最后一个非零余数。
## 同余式除法
命题：设 𝑚 为正整数，𝑎、𝑏 和𝑐为整数. 若 𝑎𝑐 ≡𝑏𝑐 (mod 𝑚) 且 gcd(𝑐, 𝑚) = 1, 则𝑎 ≡ 𝑏 (mod 𝑚).
证明： 因为 𝑎𝑐 ≡ 𝑏𝑐 (mod 𝑚), 则 𝑚 | (𝑎𝑐 − 𝑏𝑐) = 𝑐(𝑎 − 𝑏) 。
由于 gcd(𝑐, 𝑚) = 1, 所以𝑚|(𝑎 − 𝑏). 因此, 𝑎 ≡ 𝑏 (mod 𝑚)
## 唯一逆元
命题：若𝑎和𝑚是互素的整数且𝑚 > 1，则 𝑎 在模 𝑚 下有唯一逆元。
证明：1. （存在性）由于 gcd(𝑎, 𝑚) = 1，根据贝祖定理存在整数𝑠和𝑡使得: 𝑠𝑎 + 𝑡𝑚 ≡ 1(mod 𝑚). 由于 𝑡𝑚 ≡ 0 (mod 𝑚), 所以𝑠𝑎 ≡ 1 (mod 𝑚)。因此，𝑠 是 𝑎 在模 𝑚 下的逆元.
2.（唯一性）假设存在两个逆元，设为𝑠和𝑡，也即𝑠𝑎 ≡1 (mod 𝑚)且𝑡𝑎 ≡ 1 mod 𝑚 。因此，𝑠𝑎 − 𝑡𝑎 ≡ 0 (mod 𝑚)，也即(𝑠 − 𝑡)𝑎 ≡ 0 (mod 𝑚)，𝑚| 𝑠 − 𝑡 𝑎。又因为gcd(𝑎, 𝑚) =1，则𝑚| 𝑠 − 𝑡 。因此， 𝑠 ≡ 𝑡 (mod 𝑚)，也即𝑠和𝑡在模𝑚下相等。
## 中国剩余定理
### 正确性证明
考虑同余方程 $𝑥 ≡ 𝑎_𝑗 (mod 𝑚_𝑗)$，针对$𝑥 = sum_{i=1}^{n}a_iM_iM_i^{-1}$中的每个项$a_iM_iM_i^{-1}$:
- 若𝑖 ≠ 𝑗，则$M_i=\frac {m}{m_i} \equiv 0 \pmod {m_j}$
- 若𝑖 = 𝑗，由于$𝑀_i^{-1}$是$M_i$在模$𝑚_𝑖$下逆元，则$𝑀_i𝑀_i^{-1}  ≡ 1(mod 𝑚_𝑖)$.
因此，$𝑎_𝑖𝑀_i𝑀_i^{-1} ≡ 𝑎_𝑖(mod 𝑚_𝑖)$。又因为$𝑚_𝑖 = 𝑚_𝑗$，则$𝑎_𝑖𝑀_i𝑀_i^{-1} ≡ 𝑎_𝑖(mod 𝑚_𝑗)$
综上， $𝑥 = sum_{i=1}^{n}a_iM_iM_i^{-1} \equiv a_i \pmod {m_j}$
### 唯一性证明
引理：若$m_1,m_2,...,m_n$两两互素，则$m_1 | x,m_2 | x,...,m_n | x$
引理证明：当n=1时，引理自然成立
假设当n=k时成立，考虑n=k+1时的情形，记$M=m_1m_2...m_n$.根据假设，M|x，由于$m_{k+1} | x$,则$x=m_{k+1}y_{k+1}$。又因为M|x，则$x=My_M=m_{k+1}y_{k+1}$。因为$m_{k+1}$和M互素，因此$m_{k+1}|y_M$，也即$y_M= m_{k+1}z$，因而，$x= My_M = m_1m_2...m_km_{k+1}z$，也即$(m_1m_2...m_n)|x$。
唯一性证明：假设存在两个解x和y满足该同余方程，也即$x \equiv y \equiv a_k \pmod {m_k}$对于所有的$1 \leq k \leq n$都成立。因此，$m_k|(x-y)$对于所有的$1 \leq k \leq n$都成立。根据引理，$(m_1m_2...m_n)|(x-y)$。因此，$x-y \equiv 0 \pmod {m_1m_2...m_n}$，也即x和y在模$m_1m_2...m_n$下都是相同的，这证明了解的唯一性。
## Wilson定理
命题：p是素数当且仅当$(p-1)! \equiv -1 \pmod p$
证明：
**充分性**：考虑p的真因子n，也即n|p且$1 \leq n < p$。
因此，n|(p-1)!
另一方面，由于$(p-1)! \equiv -1 \pmod p$，因此p|((p-1)! + 1)。
又因为n|p，所以n|((p-1)! + 1)。
综上所述，n|1也即n=1。
p的真因子只有1，那么p是素数。
**引理**：若p为素数且$x^2 \equiv 1 \pmod p$，那么$x \equiv 1 \pmod p$或者$x \equiv {-1} \pmod p$
**引理证明**：$p|(x^2-1)$即p|(x+1)(x-1)。由于p是素数，那么p|(x+1)或者p|(x-1)，得证。
[[第1章 数论和密码学#^8df524|涉及定理：逆元唯一性]]
**必要性**：p=2或3时易证，以下考虑$p \geq 5$
考虑集合{2,3,...,p-2}，对于其中任何一个元素a，可知$a \not\equiv 1 \pmod p$且$a \not\equiv -1 \pmod p$。根据上述引理，可知$a^2 \not\equiv 1 \pmod p$。又因为a与p互素，那么a必然存在一个模p下的逆元，且该逆元不为a本身。因此，集合{2,3,...,p-2}中可以两两配对为互为逆元的对，从而$(p-1)! = 1 \cdot (p-1) \cdot (2 \cdot 3...(p-2)) \equiv p-1 \equiv -1\pmod p$，得证
## 欧拉定理
**定理命题**：若gcd(a,n)=1，则$a^{\phi(n)} \equiv 1 \pmod n$
证明：设𝑋 = {𝑥 | 𝑥为小于𝑛的正整数且gcd(𝑥, 𝑛) = 1}， 则 |𝑋| = 𝜑(𝑛);
对元素𝑎且gcd(𝑎, 𝑛) = 1,有集合𝑎𝑋 = {𝑎𝑥 mod 𝑛| 𝑥 ∈ 𝑋};
因为gcd(𝑎, 𝑛) = gcd(𝑥, 𝑛) = 1,可知gcd(𝑎𝑥, 𝑛) = 1。再看𝑎𝑋集合中任意两个元素$𝑎𝑥_𝑖 ≡ 𝑎𝑥_𝑗 (\mod 𝑛)$是否成立。若成立，则推出$𝑛|(𝑥_𝑖 − 𝑥_𝑗)$,即$𝑥_𝑖 = 𝑥_𝑗$。
因此𝑎𝑋 = 𝑋,即两个集合相等。
将集合𝑋和集合𝑎𝑋中所有元素相乘，得：$∏_{x \in X}x= ∏{y \in aX}𝑦 = ∏{x \in X} 𝑎𝑥 \mod 𝑛$
再将以上等式两边都乘𝑥在模𝑛下的逆，等式最左边为1，等式最右边为$a^{\phi(n)}$
因此$a^{\phi(n)} \equiv 1 \pmod n$, 得证
**推论命题**：若gcd(a,n)=1，则$a^x \equiv a^{x \mod {\phi(n)}} \pmod n$
证明：$x = q \cdot \phi(n) + r$，
$r = x \mod {\phi(n)}$，
则$a^x = a^{q\phi(n)+r} \equiv a^r \equiv a^{x \mod \phi(n)} \pmod n$
## RSA正确性证明
[[第1章 数论和密码学#^d57584|欧拉定理]]
[[第1章 数论和密码学#^d382e0|费马小定理]]
1. 若m和n互素，由欧拉定理的推论$c \equiv m^w \equiv m^{w \mod \phi(n)} \pmod n$。因此，$D(c) = c^d \mod n \equiv m^{wd \mod \phi(n)} \equiv m \mod n$，也即加解密之后可以得到原数据段。
2. 若m和n不互素，由于n = pq，则m中必定包含p或者q因子。不失一般性，设m中包含p因子，因此m可以表示为m = cp。由于$m \neq n$，则$c \nmid q$。由费马小定理可知，$m^{q-1} \equiv 1 \pmod q$。由于d为w在模$\phi(n)$下的逆，从而存在k使得$dw = k\phi(n) + 1$。考虑$m^{k\phi(n)} \equiv m^{k(p-1)(q-1)} \equiv 1 \pmod q$，也即存在整数t使得$m^{k\phi(n)} = tq + 1$，从而$m^{k\phi(n)+1} = (tq + 1)m = tmq + m = tcpq + m = tcn + m$。因此，$m^{k\phi(n) + 1} \equiv m \pmod n$，也即$D(c) \equiv c^d \equiv m^{dw} \equiv m \pmod n$。
# 计数
## 鸽巢原理相关
**鸽巢原理**：
命题：若 𝑘 是一个正整数，将 𝑘+1 个物体放入 𝑘 个盒子中，则至少有一个盒子包含两个或更多的物体.
证明：我们使用反证法进行证明。假设没有一个盒子里有超过一个物体，那么所有盒子里的物体总数最多为 𝑘。但这与我们有 𝑘+1 个物体的假设相矛盾。因此，至少有一个盒子必须包含两个或更多的物体.
**推论**：
命题：从一个具有 𝑘+1 个元素的集合到一个具有 𝑘 个元素的集合的函数 𝑓 不是一一对应的.
证明：使用鸽巢原理.
• 为 𝑓 的值域中的每个元素 𝑦 创建一个盒子.
• 将所有使得 𝑓(𝑥)=𝑦的定义域中的元素 𝑥 放入对应的盒子中.
• 因为定义域中有 𝑘+1 个元素，而值域中只有 𝑘 个盒子，所以至少有一个盒子里会有两个或更多的元素.
因此，函数 𝑓 不能是一一对应的.
**广义鸽巢原理**：
命题：如果将 𝑁 个物体放入 𝑘 个盒子中，则至少
有一个盒子包含至少 $\lceil \frac{N}{k} \rceil$ 个物体
证明：我们使用反证法进行证明.假设没有任何一个盒子包含超过 ⌈𝑁/𝑘⌉−1个物体。这样，每个盒子最多有 ⌈𝑁/𝑘⌉−1个物体。由于有 𝑘 个盒子，因此总的物体数量至多为
$k(\lceil \frac{N}{k} \rceil-1) < k((\frac{N}{k}+1)-1) = N$
这与我们有 𝑁 个物体的事实矛盾.