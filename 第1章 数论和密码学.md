# 除法和模运算
## 整除
### 定义
如果a，b是整数，且a != 0，那么如果存在一个整数c，使得b = a \* c，则称a整除b，记作a | b。
### 性质
*定理1*. a b c 都是整数，且a != 0，那么有：
- 若a | b 且 a | c，那么a | (b + c)；[[相关证明过程#整除性质|证明]]
- 若a | b，那么a | bc对所有的整数c都成立；
- 若a | b 且 b | c，那么a | c；
### 除法算法
1. 定义：若𝑎是整数，𝑏 是正整数，则存在唯一的整数 𝑞 和 𝑟，使得 0≤𝑟<𝑏，
并且 𝑎=𝑏𝑞+𝑟。[[相关证明过程#除法算法|相关证明]]
2. 换言之，可以尝试通过将一个数字分解为**除数**乘以**商**加**余数**的形式来对问题进行分析。
3. 良序原理：每个非空的自然数集都有最小的元素。 ^9f634d
## 同余关系
### 定义
如果 𝑎 和 𝑏 是整数，且 𝑚 是正整数，那么当 𝑚 整除 𝑎−𝑏
时，称 𝑎 与 𝑏 在模 𝑚 下同余，记作 𝑎 ≡ 𝑏 (mod 𝑚)。
### 性质
- 除数的唯一性:*定理2*. 设 𝑚 为正整数。当且仅当存在一个整数 𝑘 使得𝑎=𝑏+𝑘𝑚，整数 𝑎 和 𝑏 在模 𝑚 意义下同余。[[相关证明过程#除数的唯一性|证明]]
- 对称性：𝑎 ≡ 𝑎 (mod m)
- 自反性/反身性：若𝑎 ≡ 𝑏 (mod 𝑚) 则𝑏 ≡ 𝑎 (mod m)
- 传递性：若𝑎 ≡ 𝑏 (mod 𝑚)且𝑏 ≡ 𝑐 (mod 𝑚) ，则𝑎 ≡ 𝑐 (mod 𝑚)
### 附注
(mod m) 和 mod m的区别：
- 前者类似表明一种**性质**，表示模m的意义下二者同余
- 后者表示一种**运算**，是一个返回余数的函数
- *定理 3*:设 𝑎 和 𝑏 为整数，𝑚 为正整数，则 𝑎≡𝑏 (mod 𝑚) 当且仅当 𝑎 mod  𝑚=𝑏 mod  𝑚.
### 运算
#### 同余式的加法和乘法运算
*定理 4*:设 𝑚 为正整数。如果 𝑎≡𝑏 (mod 𝑚) 且 𝑐≡𝑑 (mod 𝑚)，则
𝑎+𝑐≡𝑏+𝑑 (mod 𝑚) 且 𝑎𝑐≡𝑏𝑑 (mod 𝑚)。[[相关证明过程#同余式的加法和乘法运算|证明]]
*定理4推论1*：将有效同余式的两边同时乘以一个整数会保持其有效性；将一个整数加到一个有效同余式的两边也会保持其有效性。~~其实是废话~~
**值得注意的是**，将同余式两边同时除以一个整数并不总能产生有效的同余关系。
*定理4推论2*:设 𝑚 为正整数，𝑎 和 𝑏 为整数，则
(𝑎 + 𝑏) (𝒎𝒐𝒅 𝑚) = ((𝑎 𝒎𝒐𝒅 𝑚) + (𝑏 𝒎𝒐𝒅 𝑚)) 𝒎𝒐𝒅 𝑚
且
𝑎𝑏 𝒎𝒐𝒅 𝑚 = ((𝑎 𝒎𝒐𝒅 𝑚) (𝑏 𝒎𝒐𝒅 𝑚)) 𝒎𝒐𝒅 m
**换言之**，和的模等于模的和的模，积的模等于模的积的模，可以看成一种简化运算
#### 二进制模幂算法
在密码学当中，我们需要高效运算\($b^n mod m$)的数值
使用n的二进制展开，n=$(a_{k-1},a_{k-2},...a_0)_2$ 来计算 $b^n$
注意到：$b^n = b^{a_{k-1} * 2^{k-1}+...+a_1*2+a_0} = (b^{2^k-1})^{a_{k-1}}...(b^2)^{a_1}b^{a0}$
该算法依次计算$b mod m, b^2 mod m, b^4 mod m...$
然后将$a_j = 1$ 的项相乘
**换言之**，就是通过将幂次拆解成二进制的形式来达到简化运算的目的。
## 群，环，域
考试不考，先跳过这里
## 模m算数运算
### 定义
给定一个$Z_m$是一个包含从0到m-1的非负整数的集合，即{0，1，...，m-1}
- 加法 $+_m$ 定义为$a+_mb=(a+b)mod m$
- 加法 $·_m$ 定义为$a·_mb=(a·b)mod m$
- 这些运算被称为**模m的算数运算**
# 素数和最大公约数
## 素数
### 定义
对于一个**大于1**的正整数p，若p的正因子只有1和p本身，则称p为素数；一个大于1且非素数的正整数称之为合数。
### 算数基本定理
*定理*：每一个大于1的正整数都可以**唯一的**表示为一个素数，或者表示为两个或更多素数的乘积，其中素因数按照大小不减的顺序排列。即$p=a_1a_2...a_n$，其中$a_1\leq a_2...\leq a_n$ [[相关证明过程#算数基本定理|证明]]
## 最大公约数
### 定义
设a,b为整数，且**不全为0**。能够同时整除a和b的**最大整数**d称为a和b的最大公约数，记作$gcd(a,b)$
**值得注意的是**，当a,b两者中存在负数时可以将其视作绝对值，因为定义为**最大整数**。
### 最大公约数表示成一个线性组合
*定理*：若a和b是任意整数且不全为0，则$gcd(a,b)$是集合$\{ax+by|x,y \in Z\}$中的最小正整数元素。[[相关证明过程#最大公约数表示成一个线性组合|证明]]
*推论*：对于整数a和b,若d|a且d|b，则d | gcd(a,b)
*贝祖定理*：若a和b是正整数，则存在整数s和t使得gcd(a,b) = sa+tb.这样的s和t被称为**贝祖系数**。 ^454639
## 素数测试及试除法
### 试除法
*定理*：若a是合数，则a必有小于或等于$\sqrt{a}$的因子。
*推论*：若a是合数，则a必有小于或等于$\sqrt{a}$的素因子。[[相关证明过程#试除法|证明]]
*试除法*：依次将小于等于$\sqrt{a}$的素数除a来判断a是否是素数。
### 埃拉托斯特尼筛法
输入：正整数 n
输出：所有小于等于 n 的素数
1. 创建布尔数组 isPrime[2..n]，初始化所有值为 true
2. 从 p = 2 开始
3. 当 p² ≤ n 时：
   a. 如果 isPrime[p] 为 true：
      - 从 p² 开始，标记 p 的所有倍数为 false
      - 步长为 p
   b. p = p + 1
4. 收集所有 isPrime[i] 为 true 的 i 值
5. 返回素数列表
*换言之*，其实就是从前往后遍历进行排除的过程。
## 无穷素数
### 定理
素数的个数是无限的。[[相关证明过程#无穷素数|证明]]
## 梅森素数
### 定义
形如$2^{p} - 1$的素数，其中p为素数，被称为梅森素数。
那么反过来，当n是合数时，$2^n - 1$一定是合数：$2^{ab} - 1 = (2^a - 1)(2^{a(b - 1)} + 2^{a(b - 2)} + ...+2^a + 1)$
## 素数的分布规律
不超过x的素数个数与$\frac{x}{ln x}$的比率随着x的增大而趋近于1.
由该定理可知：
- 不超过x的素数个数可以用$\frac{x}{ln x}$来近似；
- 随机选择一个小于n的正整数是素数的概率大约是$\frac{(\frac{n}{ln n})}{n} = \frac{1}{ln n}$.
## 生成素数
生成大素数的问题在各个方面都存在重要意义，但是目前为止，还没有找到一种总能够生成素数的有效的闭合公式，没有一个具有整数系数的多项式f(n)能够使得每一个n都是素数。
进一步地，没有一个简单的函数f(n)使得f(n)对所有正整数n都为素数。
## 互素
### 定义
如果两个整数a和b的最大公约数为1，则称a和b互素。
### 素因子分解法找最大公约数
$a = p_1^{a_1}p_2^{a_2}...p_n^{a_n}$，$b = p_1^{b_1}p_2^{b_2}...p_n^{b_n}$，
其中每个指数都是非负整数，且两个素因数分解中出现的所有素数都包含在两者当中，那么：
$gcd(a,b) = p_1^{min(a_1,b_1)}p_2^{min(a_2,b_2)}...p_n^{min(a_n,b_n)}$.
## 欧几里得算法/辗转相除法
理论基础：当$a \geq b 且 c = a \mod b$，则$gcd(a,b) = gcd(b,c)$。
[[相关证明过程#欧几里得算法|正确性证明]]
~~好了掌握了上述公式后面的就可以不用了解了~~
辗转相除法其实就是不断用大者除以小者，而后小者更新为大者，余数更新为小者，直到小者为0循环终止。
## 最小公倍数
### 定义
正整数 𝑎 和 𝑏 的最小公倍数是同时能被𝑎和𝑏整除的最小正整数，记作 lcm(𝑎, 𝑏).
最小公倍数也可以通过素因数分解来计算：
$lcm(a,b) = p_1^{max(a_1,b_1)}...p_n^{max(a_n,b_n)}$
## 求贝祖系数
[[第1章 数论和密码学#^454639|贝祖定理]]
### 定义
若 𝑎 和 𝑏 是正整数，则使得 gcd(𝑎, 𝑏) = 𝑠𝑎 + 𝑡𝑏的整数 𝑠 和 𝑡 称为 𝑎 和 𝑏 的贝祖系数
### 两步法求贝祖系数
**简言之**，就是先通过欧几里得算法求出最大公约数，然后通过前述运算过程回代得到贝祖系数
### 扩展欧几里得算法求贝祖系数
**目标**：求满足$xa + yb=\gcd(a,b)$的x和y，假设$a \geq b$
通过欧几里得算法，gcd(a,b) = gcd(b,a mod b)
那么就存在x'和y'使得x'b+y'a = gcd(b, a mod b)
这样我们就可以依次进行迭代：$x = y'，y = x' - y' \lfloor a/b \rfloor$
直到得到我们需要的系数。
## 同余式的除法
*定理*：设m为正整数，a，b，c是整数，若$ac \equiv bc \pmod m$且$\gcd(c,m) = 1$，那么$a \equiv b \pmod m$
[[相关证明过程#同余式除法|证明]]
# 求解同余方程
## 线性同余式
### 定义
形如$ax \equiv b \pmod m$的同余式，其中m为正整数，a和b是整数，x是变量，称为线性同余式。
线性同余式$ax \equiv b \pmod m$的解是所有满足该同余式的整数x
### 逆元
若整数$\overline{a}$满足$\overline{a}a \equiv 1 \pmod m$，则称$\overline{a}$为a模m的逆元。
*定理1*：若a和m是互素的整数且m > 1，则a在模m下有唯一逆元
[[相关证明过程#唯一逆元|证明]] ^8df524
### 逆元求解
欧几里得算法和贝祖系数提供了一种系统求解逆元的方法
*目标*：求解a在模m下的逆元
*方法*：
- 扩展欧几里得算法求解$xa + ym = \gcd(a,m) = 1$
- 两边同时模m，可得$xa \equiv 1 \pmod m$
*前提*：gcd(a,m) = 1
*结果*：$ax \equiv b \pmod m$，$\overline{a}a \equiv 1 mod m$，
那么$\overline{a}ax \equiv x \equiv \overline{a}b \pmod m$
可以求解同余方程
## 中国剩余定理
*定理2*：设$m_1,m_2,...,m_n$是两两互素且大于1的正整数，$a_1,a_2,...,a_n$是任意整数，那么以下同余方程组：
$x \equiv a_1 \pmod {m_1}$
$x \equiv a_2 \pmod {m_2}$
...
$x \equiv a_n \pmod {m_n}$
有唯一的解模$m = m_1m_2...m_n$ / 即存在解x，使得$0 \leq x < m$，且所有其他解与该解模m同余
*求解过程*：
1. 计算所有模的积$m = m_1m_2...m_n$
2. 针对每个同余方程$x \equiv a_k \pmod {m_k}$，
	1. 计算$M_k = \frac{m}{m_k}$
	2. 利用扩展欧几里得算法计算模$M_k$在模$m_k$下的逆元，记作$M_k^{-1}$
3. $x = (sum_{i=1}^{n}a_iM_iM_i^{-1}) \mod m$
[[相关证明过程#中国剩余定理|证明]]
## 回代法
将每一个同余方程转化为等式，代入变量的值到另一个同余方程中，持续该过程直到解出所有同余方程
*简言之*，其实就是瞪眼法
## Wilson定理
*定理*：p是素数当且仅当$(p-1)! \equiv -1 \pmod p$
[[相关证明过程#Wilson定理|证明]]
## 欧拉函数
### 定义
$\phi(n)$：定义为比n小且与n互质的正整数的个数
### 性质
- 若p是素数，则$\phi(p) = p -1$
- 若n是合数且n=pq,其中p和q是两个不同的素数，则$\phi(n) = (p-1)(q-1)$
## 欧拉定理

^d57584

*定理*：若gcd(a,n)=1，则$a^{\phi(n)} \equiv 1 \pmod n$
*推论*：若gcd(a,n)=1，则$a^x \equiv a^{x \mod {\phi(n)}} \pmod n$
[[相关证明过程#欧拉定理|证明]]
欧拉定理在后续的密码学中还会有涉及，较为重要，应当掌握。
## 费马小定理

^d382e0

*定理*：如果p是一个素数且a是一个不被p整除的整数，则有$a^{p-1} \equiv 1 \pmod p$；此外，对于每个整数a，都有$a^p \equiv a \pmod p$，
- 若a与p互素，$a^p \equiv a \pmod p \leftrightarrow a^{p-1} \equiv 1 \pmod p$
- 若a与p不互素，$a^p \equiv a \equiv 0 \pmod p$
## 伪素数
### 定义
设 b 是一个正整数。如果 𝑛 是一个合数，且 $b^{n-1} ≡ 1 \pmod n$，那么 𝑛 被称为基数 𝑏 的伪素数
### 补充
给定一个正整数n，
- 若$2^{n-1} \not\equiv 1 \pmod n$，那么n是合数
- 若$2^{n-1} \equiv 1 \pmod n$，那么n可能是素数，也可能是基数2的伪素数
## 原根
### 定义
一个素数p的原根是指$Z_p$中的一个整数r，使得$Z_p$中的每一个非零元素都是r的某个幂
*换言之*，其实就是对于一个数字的最小分隔集，我们要找这样的一个数字r使得这个集合内的每一个元素能够与r的某个幂次形成一一对应关系。此时我们就能够说r是素数p的一个原根。
**应当注意的是**，对于每一个素数p，总存在一个原根。
## 离散对数
### 定义
设 𝑝 是一个素数，𝑟 是模 𝑝 的一个原根，且 𝑎 是位于 1 到 𝑝−1之间的整数。若 $𝑟^e \mod 𝑝 = 𝑎$，且 1 ≤ 𝑒 ≤ 𝑝 − 1，我们称 𝑒 为模 𝑝以 𝑟 为底数的 𝑎 的离散对数， 写作$log_r 𝑎 = 𝑒$ (其中素数𝑝是默认的).
*换言之*，其实就是上文中提到的那个幂次被称之为离散对数
**值得注意的是**，目前没有已知的多项式时间算法来计算离散对数
~~就是要手算的意思~~
# 同余式的应用
## 哈希函数
### 定义
哈希函数 ℎ 将具有键 𝑘 的记录分配到存储位置 ℎ(𝑘)
*换言之*，一一映射关系
## 伪随机数
## 数字校验位
### 校验位：UPCs
在末尾添加一个额外的数字，并通过特定函数进行评估。若末尾数字不正确，则判定该字符串不正确.
### 校验位：ISBNs
图书通过国际标准图书编号（ISBN-10）来识别，为10位数字代码。前9位用于标识语言、出版社和图书。第10位是校验位，通过以下关系确定：
$x_10 = (\Sigma_{i=1}^{9}ix_i)\mod 11$
# 密码学
**值得注意的是**，字母是从0到25的序号
## 凯撒密码/移位密码
加密函数$f(p) = (p + k) \mod 26$
解密函数$f(p)^{-1} = (p - k) \mod 26$
## 仿射密码
移位密码是仿射密码的一种特殊形式，仿射密码如下：
加密函数：$f(p) = (ap + b) \mod 26$
解密函数：$f(p)^{-1} = a^{-1}(p - b) \mod 26$
**有趣的是**，有些时候我们并不需要完全了解这些参数依然能够完成对密码的解读；在英文的文本当中，最常见的九个字母及其出现频率如下：
E 13%，T 9%，A 8%，O8%，I 7%，N 7%，S 7%，H 6%，R 6%
可以通过统计出现频率以确定位移参数。
## 块密码
将字母表中的每个字母替换为另一个字母的密码被称为字符密码或者单字母替换密码，但是由于上文所说，容易因统计字母频率导致被破解，分组密码应运而生。
密钥是集合 {1,2, … , 𝑚}的一个置换 𝜎，其中 𝑚 是一个整数，它是从 {1,2, … , 𝑚} 到自身的单射函数。
加密消息时，将字母分成大小为 m 的块，并添加额外的字母以填满最后一个块。、
## 密码系统
### 定义
一个密码系统是一个五元组 (P, C, K, E, D)，其中
• P 是明文字符串的集合,
• C 是密文字符串的集合,
• K 是密钥空间（所有可能密钥的集合），
• E 是加密函数的集合
• D 是解密函数的集合.
E中使用密钥 𝑘 的**加密函数**记作$E_𝑘$ ；解密 $𝐸_𝑘$ 加密的密文的**解密函数**属于 𝐷，记作$𝐷_𝑘$ 。
因此: $𝐷_𝑘(𝐸_𝑘(𝑝)) = 𝑝$ 对于所有明文字符串 𝑝 成立.
### RSA密码系统
选择两个不相等的大素数p,q，n = pq，
选择一个与$\phi(n)$互素的正整数w，设d为w在模$\phi(n)$下的逆
- 加密密钥：w，n
- 解密密钥：d，n
- 需保密数据：p，q，$\phi(n)$，d

- 加密算法：$c = E(m) = m^w \mod n$
- 解密算法：$D(c) = c^d \mod n$
- 其中m是原文序号
### 加密协议：密钥交换
密钥交换是一种加密协议：双方可在没有任何过去共享秘密信息的情况下，通过不安全的通道交换一个秘密密钥。
**Diffie-Hellman密钥交换**：
1. 选择公共参数，A和B选择一个大素数p和一个原根g(模p)
2. 各自选择私钥，A选择的私钥是a，B选择的私钥是b
3. 各自计算公钥，$A = g^a \mod p$，$B = g^b \mod p$，然后将各自的公钥发给对方
4. 接受公钥之后各自计算共享密钥$B^a \mod p = A^b \mod p$，得到相同的共享密钥
**简言之**，其实这个效果类似于：
- A，B均有公钥$e_A，e_B$，私钥$d_A，d_B$
- 传递时（我们假设是A向B传递），A先使用己方私钥签名，对方公钥加密；然后B使用己方私钥解密，对方公钥解签。